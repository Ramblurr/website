---
layout: no-sidebar
title:  "Choice of server architecture"
date:   2014-11-03 17:00:00
categories: [release, docker, systemd]
image: docker.jpg
---

We finally started running the first two IndieHosters servers! This website is hosted on it, for instance. Version 0.1 of the server setup
is really quite basic. We try to avoid writing software as much as we can, and focus on hosting software built by other people.

We want to fill the gap between the free software product that says "We're open source! You can host this on your own server!" and the
end-user, who often doesn't want to (learn how to) host software on servers.

Hosting software on servers is often not very hard, at least not if you have experience with using the Linux command-line.
Of course you get better and better of the years while you do it more often, but it's mainly
a matter of following the instructions and recipes you're given, applying a bit of common knowledge about how server software usually
organizes its configuration, processes, and logs, and whenever something doesn't work, search the forums for a solution.

## Why we chose a generic Linux

We chose a Docker+systemd setup, for several reasons. First, we want to be able to offer any personal server appliation someone may want.
This means we don't want to commit to a specific personal server management tool. There are several projects that are working on graphical
user interfaces for server administration. They are like "meta software": it's software you install once using the Linux command-line (or
it comes preinstalled on a physical device you buy), and after that it works like a graphical "app store", where you can install other
software (sometimes called apps, plugins, etcetera) very easily (typically with one click on some "Install" icon).

Examples of such generic meta-software projects are:

* [FreedomBox](https://freedomboxfoundation.org/)
* [SandStorm](https://sandstorm.io)
* [Y-U-No-Host](https://yunohost.org/)
* [ownCloud](https://owncloud.org/) (where apps need to be PHP)
* [CozyCloud](https://cozy.io/) (where apps need to be NodeJS)

We want to offer hosting for all these products, as well as for more specific server applications like postfix (email), Wordpress (blogging),
etcetera. We also want to help small and young free software projects to gain traction by offering hosting for them before the big hosting
companies do this.

## Why we chose Docker

A lot of applications are available as LAMP applications, and by using Docker, we can easily offer all of these in a safe containerized environment. If one of these applications contains a cross-site scripting or SQL injection vulnerability, then this should stay entirely sandboxed,
and not affect the other applications the user runs. Docker provides this separation, as it is based on Linux containers. Also, Dockerfiles
provide an easy way to script the install steps of any Linux-based application in a reproducible way. For instance, this website has a
[Dockerfile](https://github.com/indiehosters/website/blob/source/Dockerfile) which specifies exactly which version of grunt and jekyll you need
to build it from the markdown source, and because the build happens in a Docker container, someone building it on an Ubuntu laptop gets exactly the same output as someone else building it on a Macbook.

By using Dockerfiles to describe exactly, and reproducibly, which application and configuration gets installed on a server, we will be able to easily offer hosting for hundreds of personal server setups. Yet we are being very careful not to add a layer of software ourselves. We only
translate the build instructions of the upstream project to a Dockerfile, configure which port should be opened, and Docker does the rest.

Apart from containerization, and reproducible build instructions, another great feature are Docker volumes. As containers run, they have the
possibility to build up state: files like logs and user data change on the container's internal filesystem, relative to their virgin state. When you reset (i.e., stop, remove, and start) the container, this state is reset to the initial virgin state.

By mounting volumes from the host system into a Docker container for exactly the data you want to persist, this can be avoided. That we, we can
specify exactly what parts of the file system tree we consider "user data", and which parts are either part of the image, or can be reset to their virgin content from the image without affecting the application. This way, it is even possible to reset a container to its initial state
in between two http requests - as long as the place where the user sessions are stored is marked as data we want to mount in from the host
system, so that it is preserved across container resets.

## Why we chose systemd

We could of course use Docker directly from the command line. We could write some simple bash scripts that call the right Docker commands
for adding and removing processes on a server. However, there are a number of things that would be awkward to do from plain bash scripts.
For instance, only schedule a git pull for those servers which have been configured with the option to pull their content from some git
repository, and not for others. Or, making sure the webserver starts after the database server, and only if the database server was started
successfully.

For this, we use systemd. It handles the dependencies between different containers, organizes the specific Docker commands we want to be
executed to achieve different goals into its unit files syntax, and also replaces crontab. In line with the [CoreOS](https://coreos.com/)
philosophy for running lean host systems for Docker hosting, we also use etcd to keep track of some system state (e.g. which application
is currently listening on which IP on the internal network), and confd templating to generate for instance the haproxy config file.

## Version 0.1 now available!

We tagged a [version 0.1](https://github.com/indiehosters/indiehosters/releases) in the repository containing our systemd unit files.
It contains basically two scripts: one
script for setting up a server with one default domain on there, and one scripts for adding another site to it. You can try it out
using the instructions in the README (using Vagrant is the easiest way to see the development version running on your laptop).

In this first initial version, the functionality is still very limited: it allows you to host several website over https on one IPv4
address using the SNI feature of haproxy. Each site can pull from a git repository every 10 minutes, or you can just ssh to the host
system to edit its html content. The backends run plain nginx in this version, so no php or mysql is available.

Additionally, a [postfix-forwarder](https://github.com/indiehosters/dockerfiles/blob/master/server-wide/postfix/Dockerfile) is included
which will forward email to a secondary address.
See the [data](https://github.com/indiehosters/indiehosters/tree/master/data/server-wide/postfix) folder of the IndieHosters repo for an example of how to configure it.

To get a feel for what such unit files look like, check out the [unit-files](https://github.com/indiehosters/indiehosters/blob/master/unit-files/wordpress%40.service) folder.

Feedback welcome! We're already making a lot of progress on version 0.2, which will include the necessary unit files for hosting LAMP applications like Wordpress and ownCloud.
